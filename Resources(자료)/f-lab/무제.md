
beanfactory 를 이용한 방법
```java
public class HellobootApplication {  
  
    @Bean  
    public HelloController helloController(HelloService helloService) {  
       return new HelloController(helloService);  
    }  
  
    @Bean  
    public HelloService helloService() {  
       return new SimpleHelloService();  
    }  
  
    public static void main(String[] args) {  
       // 스프링 컨테이너를 초기화 하는중에 부가적인 작업을 해야하면  
       AnnotationConfigWebApplicationContext applicationContext = new AnnotationConfigWebApplicationContext() {  
          @Override  
          protected void onRefresh() {  
             super.onRefresh();  
  
             // 톰캣 기반의 서블릿 웹 서버 팩토리 생성  
             ServletWebServerFactory serverFactory = new TomcatServletWebServerFactory();  
  
             // 웹 서버 생성 및 서블릿 컨텍스트 초기화 설정  
             WebServer webServer = serverFactory.getWebServer(servletContext -> {  
                servletContext.addServlet("dispatcherServlet", new DispatcherServlet(this)).addMapping("/*");  
             });  
  
             // 웹 서버 시작  
             webServer.start();  
          }  
       };  
  
       applicationContext.register(HellobootApplication.class);  
       applicationContext.refresh();  
         
    }  
}
```


2. Componet Scanner 이용
Spring Container 에는 Componet Scanner 가 있음 @ComponentScan을 붙이면 됨.
@Component 붙어 있는 모든 클래스를 찾아 Bean으로 등록해줌.
좋은 점  : 새로운 bEAN을 만들어서 추가할 때 매번 어디다가 추가할 필요 없이 @Componet annotation만 붙여주면 됨.
단점 : Bean이 많아지면 어떤 Bean이 등록됬는지 찾는게 굉장히 번거로워짐






Meta annotation
annotation 위에 붙은 annotation
Retention : 이 메타에노테이션이 언제까지 살아있을 것인가 유지할 것이가 - RetentionPolicy.RUNTIME

@Target(ElementType.Type) : 에노테이션을 적용할 대상, Target 위치에만 들어감 컴포넌트가 클래스에 붙으면 Type

왜 custom annotation
```java
package tobyspring.helloboot;  
  
import org.springframework.stereotype.Component;  
  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
  
@Retention(RetentionPolicy.RUNTIME)  
@Target(ElementType.TYPE)  
@Component  
public @interface MyComponent {  
}
```
가끔 @Compoent 가 붙었는데 명확하게 표현해주고 싶을때 이렇게 만들어서 쓸 수 있음...
근데 Spring이 만든게 있음 
@Controller 이런거...



@RestController와 @Controller 차이
@RestController 는 @Controller는 메타 에노테이션으로 붙이고 ResponseBody까지 있음
API로 기능을 하는 cONTROLLER METHOD를 만들때는 CONTROLLER Method가 리턴하는 값을 그대로 응답의 body에 리턴하는 방식을 씀 그래서 이런게 필요한거임.

그리고 @controller @ResctControoler 를 사용하면
@RequestMapping 을 굳이 클래스 레벨에 선언하지 않아도 dispatchServlet이 
이 안에 mapping 정보가 담겨 있다 생각하고 알아서 찾아줌. 메소드레벨에 메핑을 해주면됨.
```java
@RestController  
public class HelloController {  
    private final HelloService helloService;  
  
    public HelloController(HelloService helloService) {  
        this.helloService = helloService;  
    }  
  
    @GetMapping("/hello")  
    public String hello(String name) {  
        return helloService.sayHello(Objects.requireNonNull(name));  
    }  
}
```


dispatcher Servlet은 자기가 이용한 controller를 찾아야하기때문에 spring container를 넘겨줘야하는거임.
servletContext.addServlet("dispatcherServlet", new DispatcherServlet(this)).addMapping("/*");

```java
package tobyspring.helloboot;  
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;  
import org.springframework.boot.web.server.WebServer;  
import org.springframework.boot.web.servlet.server.ServletWebServerFactory;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.ComponentScan;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  
import org.springframework.web.servlet.DispatcherServlet;  
  
@Configuration  
@ComponentScan  
public class HellobootApplication {  
    @Bean  
    public ServletWebServerFactory servletWebServerFactory() {  
       return new TomcatServletWebServerFactory();  
    }  
  
    @Bean  
    public DispatcherServlet dispatcherServlet() {  
       return new DispatcherServlet();  
    }  
  
    public static void main(String[] args) {  
       // 스프링 컨테이너를 초기화 하는중에 부가적인 작업을 해야하면  
       AnnotationConfigWebApplicationContext applicationContext = new AnnotationConfigWebApplicationContext() {  
          @Override  
          protected void onRefresh() {  
             super.onRefresh();  
  
             // 톰캣 기반의 서블릿 웹 서버 팩토리 생성  
             ServletWebServerFactory serverFactory = this.getBean(ServletWebServerFactory.class);  
             DispatcherServlet dispatcherServlet = this.getBean(DispatcherServlet.class);  
//           dispatcherServlet.setApplicationContext(this);  
  
             // 웹 서버 생성 및 서블릿 컨텍스트 초기화 설정  
             WebServer webServer = serverFactory.getWebServer(servletContext -> {  
                servletContext.addServlet("dispatcherServlet", dispatcherServlet).addMapping("/*");  
             });  
  
             // 웹 서버 시작  
             webServer.start();  
          }  
       };  
  
       applicationContext.register(HellobootApplication.class);  
       applicationContext.refresh();  
  
    }  
}
```
    public DispatcherServlet dispatcherServlet() {  
       return new DispatcherServlet();  
    }  
    이 부분에서 별도로 applicationContext를 안넘겨준거는
    dispatcherServlet이 ApplicationContextAware 의 setApplicationContext 을 구현하고 있기 때문이다. 이거를 구현해놓으면 Spring Contaienr는 자기자신도 Bean에 등록을 하는데
    알아서 자기자신을 등록해준다..
      그래서 알아서 돌아간다..
```java
@RestController  
public class HelloController {  
    private final HelloService helloService;  
    private ApplicationContext applicationContext;  
  
    public HelloController(HelloService helloService, ApplicationContext applicationContext) {  
        this.helloService = helloService;  
        this.applicationContext =applicationContext;  
  
        System.out.println("sprong contaienr 자기 자신인 applicationContext가 자동으로 들어오나 확인" + applicationContext);  
    }  
  
    @GetMapping("/hello")  
    public String hello(String name) {  
        return helloService.sayHello(Objects.requireNonNull(name));  
    }  
  
}
```

그래서 이런식으로 applicationContext를 받게끔 해보면 console이찍히는 것을 볼 수 있음 신기하다.


```java
package tobyspring.helloboot;  
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;  
import org.springframework.boot.web.server.WebServer;  
import org.springframework.boot.web.servlet.server.ServletWebServerFactory;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.ComponentScan;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  
import org.springframework.web.servlet.DispatcherServlet;  
  
@Configuration  
@ComponentScan  
public class HellobootApplication {  
    @Bean  
    public ServletWebServerFactory servletWebServerFactory() {  
       return new TomcatServletWebServerFactory();  
    }  
  
    @Bean  
    public DispatcherServlet dispatcherServlet() {  
       return new DispatcherServlet();  
    }  
  
    public static void main(String[] args) {  
       // 스프링 컨테이너를 초기화 하는중에 부가적인 작업을 해야하면  
       run(HellobootApplication.class);  
    }  
  
    private static void run(Class<?> applicationClass) {  
       AnnotationConfigWebApplicationContext applicationContext = new AnnotationConfigWebApplicationContext() {  
          @Override  
          protected void onRefresh() {  
             super.onRefresh();  
  
             // 톰캣 기반의 서블릿 웹 서버 팩토리 생성  
             ServletWebServerFactory serverFactory = this.getBean(ServletWebServerFactory.class);  
             DispatcherServlet dispatcherServlet = this.getBean(DispatcherServlet.class);  
  
             // 웹 서버 생성 및 서블릿 컨텍스트 초기화 설정  
             WebServer webServer = serverFactory.getWebServer(servletContext -> {  
                servletContext.addServlet("dispatcherServlet", dispatcherServlet).addMapping("/*");  
             });  
  
             // 웹 서버 시작  
             webServer.start();  
          }  
       };  
  
       applicationContext.register(applicationClass);  
       applicationContext.refresh();  
    }  
}
```

여기서 class는 @configuratioin 이 붙은 클래스여야하고 compoentScan과 facotrial method를 가지고 스프링 컨테이너에게 application 구성들을 가지고 있는 클래스여야함..

테스트 스텁(test stub)이라고 합니다. 테스트 대상 객체가 동작하는데 필요한 협력 오브젝트의 기능을 간단히 구현해 놓은 것을 말합니다.